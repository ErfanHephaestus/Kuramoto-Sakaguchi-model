// Kuramoto model.cpp 
//created by ErfanHephaestus

#include <iostream>
#include<cstdlib>
#include <ctime>
#include <fstream>
#include <vector>
#include<algorithm>
#include <random>
#include <limits>
using namespace std;

typedef unsigned short int ushort;	//defining new name for type
const ushort N = 1000;	// Number of nodes in the network
const float P = 0.025;	// probability
const float couplingStrength = 0.08; //coupling strength
const int Time = 50000;
const float frustration = 0.0;	//If it is non-zero your modle becomes Sakaguchi-Kuramoto model
const float dt = 0.01;	//Time steps for Euler model
void erdosRenyi(ushort** const adjmat);	//This function creates Erdős–Rényi graph
double generateGaussianNoise(double mu, double sigma);	//This function creates Gaussian random number mu represent mean and sigma represent standard deviation
void initializer(vector<double>& w , double** phase);	//This function initialize natural frequency and phases
int main()
{
	srand(time(0));	//seeding random number generator

	//creating 2D array on the heap for adjacency matrix
	ushort** adjacencyMatrix = NULL;
	adjacencyMatrix = new ushort * [N];
	for (ushort i = 0; i < N; ++i)
		adjacencyMatrix[i] = new ushort[N];

	//calling function to create Erdős–Rényi graph
	erdosRenyi(adjacencyMatrix);
	
	vector<double> naturalFrequency(N, 0.0);	//Creating vector to store natural freuency
	
	//Creating 2D array on the heap to store phases
	double** theta = NULL;
	theta = new double* [N];
	for (ushort i = 0; i < N; i++)
		theta[i] = new double[Time];

	//initializing natural frequency and phases
	initializer(naturalFrequency , theta);
	sort(naturalFrequency.begin(), naturalFrequency.end());	//sort natural frequency

	//Kuramoto dynamic
	ofstream orderparameter("orderparameter.dat", ios::out | ios::trunc);	// it stores order parameter r in .dat file
	float r = 0;	//order parametar
	for (int t = 1; t < Time; t++)
	{
		r = 0.0;
		for (int j = 0; j < N; j++)
		{
			float sum = 0.0;
			for (int k = 0; k < N; k++)
			{
				sum += sin(theta[k][t - 1] - theta[j][t - 1] - frustration) * adjacencyMatrix[j][k];
			}
			theta[j][t] = theta[j][t - 1] + (naturalFrequency[j] + couplingStrength * sum) * dt;
		}
		float rc = 0.0, rs = 0.0;
		for (int j = 0; j < N; j++)
		{
			rc += cos(theta[j][t]);
			rs += sin(theta[j][t]);
		}

		r = (sqrt(pow(rc, 2) + pow(rs, 2))) / N;	//caculating order paramater

		orderparameter << t << "        " << r << endl;
	}
	//freeing allocated memory
	for (ushort i = 0; i < N; ++i) {
		delete[] adjacencyMatrix[i];
		delete[] theta[i];
	}
	delete[] adjacencyMatrix;
	delete[] theta;


}
//function definitins:

void erdosRenyi(ushort** const adjmat)
{
	//set all array elements to zero
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j <= i; j++)
		{
			adjmat[i][j] = 0;
			adjmat[j][i] = 0;
		}
	}

	// creating graph base on probablity
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < i; j++)
		{
			double r = ((double)rand() / (RAND_MAX));
			if (r < P)
			{
				adjmat[i][j] = 1;
				adjmat[j][i] = 1;

			}
		}
	}
	ofstream adjacency("adjacencymatrix.txt", ios::out | ios::trunc);	//creating file to store result in text file
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{
			adjacency << adjmat[i][j] << "   ";

		}
		adjacency << endl;
	}
}
double generateGaussianNoise(double mu, double sigma)
{
	static const double epsilon = std::numeric_limits<double>::min();
	static const double two_pi = 2.0 * acos(-1);

	thread_local double z1;
	thread_local bool generate;
	generate = !generate;

	if (!generate)
		return z1 * sigma + mu;

	double u1, u2;
	do
	{
		u1 = rand() * (1.0 / RAND_MAX);
		u2 = rand() * (1.0 / RAND_MAX);
	} while (u1 <= epsilon);

	double z0;
	z0 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
	z1 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);
	return z0 * sigma + mu;
}
void initializer(vector<double>& w , double** phase)
{
	vector<double>::iterator iter;
	vector<double>::const_iterator ITER;
	for (iter = w.begin(); iter != w.end(); ++iter)
	{
		*iter = generateGaussianNoise(0, 1); //initialise natural frequency with Gaussian random number
	}
	ofstream naturalFreq("naturalfrequency.txt", ios::out | ios::trunc);	//creating file to store result in text file
	for (ITER = w.begin(); ITER != w.end(); ++ITER)
	{
		naturalFreq << *ITER << endl;
	}

	// uniform random number generator
	random_device rd;  //Will be used to obtain a seed for the random number engine
	mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	uniform_real_distribution<> dis(-1.0, 1.0); //random number range between -1.0 and 1.0
	/*for (int n = 0; n < 100; ++n) {
		// Use dis to transform the random unsigned int generated by gen into a
		// double in [1, 2). Each call to dis(gen) generates a new random double
		cout << dis(gen) << ' ';
	}
	cout << '\n';*/

	for (ushort i = 0; i < N; i++)
	{
		phase[i][0] = dis(gen)*acos(-1); //initialize phase between -PI and PI
	}
}